# 以下是对文本文件和二进制文件的更详细介绍:

# ### **文本文件**

# 1. **存储方式**:
#    - 文本文件以字符的形式存储数据。每个字符都由一个或多个字节组成,具体取决于使用的编码。
#       例如,ASCII 编码每个字符占用一个字节,而 UTF-8 编码中的字符可能占用多个字节。
   
# 2. **编码**:
#    - 常见的编码格式包括 ASCII、UTF-8、UTF-16 等。
#   ASCII 只能表示 128 个字符,主要用于英语,而 UTF-8 可以表示几乎所有语言的字符。
   
# 3. **文件扩展名**:
#    - 常见的文本文件扩展名有 `.txt`、`.csv`、`.html`、`.json`、`.xml` 等。
   
# 4. **使用和编辑**:
#    - 文本文件可以使用简单的文本编辑器（如记事本）或高级编辑器(如 VS Code、Sublime Text)进行编辑和查看。
#       由于文本文件以可读字符形式存储,因此其内容可以被直接查看和修改。

# 5. **优点**:
#    - 易于编辑和查看。
#    - 跨平台兼容性好。
#    - 文件大小通常较小,特别是对于只包含文本的数据。

# 6. **缺点**:
#    - 不能有效地存储复杂的数据类型,如图像或音频。




# ### **二进制文件**

# 1. **存储方式**:
#    - 二进制文件以二进制数据存储,数据不以字符的形式出现,而是以原始的二进制码进行保存。
#       这种方式更接近计算机的底层数据处理。

# 2. **文件扩展名**:
#    - 常见的二进制文件扩展名有 `.jpg`（图像）、`.mp4`（视频）、`.exe`（可执行文件）、`.dat`（数据文件）等。

# 3. **使用和编辑**:
#    - 二进制文件通常需要特定的软件或程序来读取和编辑。
#       例如,图像文件需要图像编辑器,视频文件需要视频播放器。
#       直接用文本编辑器打开二进制文件通常会看到乱码,因为文件中的数据不是以文本格式存储的。

# 4. **优点**:
#    - 能够有效地存储复杂的数据类型,如图像、音频、视频等。
#    - 对于存储效率和处理速度的要求较高。

# 5. **缺点**:
#    - 不容易直接查看和编辑。
#    - 跨平台兼容性可能较差,因为不同平台可能使用不同的二进制格式。


# ### **总结**

# 文本文件适用于存储和传输可读的文本数据,方便编辑和共享。
# 二进制文件则适用于存储复杂的数据类型和需要高效存取的数据。
# 根据需求选择合适的文件格式可以提高数据处理的效率和准确性。


# ------------------------------------------------------------------------------------------------------------------

# 模式 `x` 也有其特定用途。这里是包括 `x` 的完整文件打开模式表格：

# | 模式   | 说明                                      | 文件不存在时的行为          | 文件存在时的行为        | 文件指针位置      | 数据覆盖       |
# |--------|-----------------------------------------|---------------------------|-----------------------|-----------------|---------------|
# | `r`    | 只读模式                                  | 错误                      | 只能读取               | 文件开头          | 不覆盖         |
# | `w`    | 写入模式                                  | 创建新文件                | 从头开始覆盖           | 文件开头          | 覆盖全部内容   |
# | `a`    | 追加模式                                  | 创建新文件                | 追加到文件末尾         | 文件末尾          | 不覆盖         |
# | `r+`  | 读取和写入模式                            | 错误                      | 读取和写入内容         | 文件开头          | 不覆盖         |
# | `w+`  | 写入和读取模式                            | 创建新文件                | 从头开始覆盖           | 文件开头          | 覆盖全部内容   |
# | `a+`  | 追加和读取模式                            | 创建新文件                | 追加到文件末尾，读取从头开始 | 文件末尾或开头   | 不覆盖         |
# | `x`    | 独占创建模式                              | 创建新文件                | 错误（如果文件已存在） | 文件开头          | 不适用         |
# | `b`    | 二进制模式（与其他模式一起使用）           | -                         | -                     | -                 | -             |
# | `t`    | 文本模式（与其他模式一起使用）             | -                         | -                     | -                 | -             |

# **说明：**

# - **`x`（Exclusive Creation Mode）：** 仅在文件不存在时创建新文件。如果文件已经存在，操作将失败并引发错误。这个模式可以避免意外覆盖现有文件。


# ------------------------------------------------------------------------------------------------------------------

# 下面是文件读取和写入方法的表格形式：

# | 方法        | 说明                                      | 示例用法                              |
# |-------------|-----------------------------------------|--------------------------------------|
# | **`read(size=-1)`**   | 读取文件的内容，`size` 指定要读取的字节数；如果省略或为 `-1`，则读取整个文件。 | ```python with open('file.txt', 'r') as f: content = f.read() ``` |
# | **`readline(size=-1)`** | 读取文件的一行，`size` 指定要读取的字节数；如果省略或为 `-1`，则读取整行。 | ```python with open('file.txt', 'r') as f: line = f.readline() ``` |
# | **`readlines(hint=-1)`** | 读取文件的所有行，返回一个包含每行的列表，`hint` 限制读取的总字节数。 | ```python with open('file.txt', 'r') as f: lines = f.readlines() ``` |
# | **`seek(offset, whence=0)`** | 移动文件指针到指定位置，`offset` 为偏移量，`whence` 指定基准位置（0 为文件开头，1 为当前位置，2 为文件末尾）。 | ```python with open('file.txt', 'r') as f: f.seek(10) ``` |
# | **`tell()`**         | 返回文件指针的当前位置。                  | ```python with open('file.txt', 'r') as f: pos = f.tell() ``` |
# | **`flush()`**        | 刷新文件缓冲区，将数据写入文件。            | ```python with open('file.txt', 'w') as f: f.write('data'); f.flush() ``` |


# ### 写入方法

# | 方法        | 说明                                      | 示例用法                              |
# |-------------|-----------------------------------------|--------------------------------------|
# | **`write(string)`**  | 写入字符串到文件，字符串将覆盖文件中的内容。  | ```python with open('file.txt', 'w') as f: f.write('Hello, World!') ``` |
# | **`writelines(lines)`** | 写入一个字符串列表到文件，每个字符串将写入一行。 | ```python with open('file.txt', 'w') as f: f.writelines(['line1\n', 'line2\n']) ``` |

# ### 附加操作

# | 方法        | 说明                                      | 示例用法                              |
# |-------------|-----------------------------------------|--------------------------------------|
# | **`close()`**       | 关闭文件，释放资源。                     | ```python with open('file.txt', 'r') as f: f.close() ``` |

# 这些方法可以帮助你在 Python 中进行各种文件操作。








# 列表推导式（List Comprehension）是一种简洁的 Python 语法，
# 用于从一个已有的列表或其他可迭代对象中创建一个新的列表。它允许你在一行代码中生成一个列表，
# 通常比使用循环更简洁和直观。


# [expression for item in iterable if condition]

# expression：对每个项目进行操作或变换的表达式。
# item：当前迭代的元素。
# iterable：要迭代的对象（如列表、元组、字符串等）。
# condition（可选）：对每个项目应用的条件，只有满足条件的项目才会被包括在新列表中。

# 示例:

# numbers = [1, 2, 3, 4, 5]
# squares = [x ** 2 for x in numbers if x > 2]
# print(squares)  # 输出: [9, 16, 25]






# zip() 函数是 Python 内置的一个函数，用于将多个可迭代对象（如列表、元组、集合）打包成一个元组的迭代器。
# 每个元组包含来自所有可迭代对象的对应元素
# zip() 返回一个迭代器，其中的每个元素都是一个元组，包含来自所有输入可迭代对象的对应元素

# 示例:

# a = [1, 2, 3]
# b = [['a', 'b', 'c'],
#      ['d', 'e', 'f'],
#     ]
# c = zip(a, b)
# print(list(c))


# 在 Python 中，**迭代器** 是一个可以逐个访问其元素的对象，而不需要一次性将所有元素加载到内存中。`zip()` 函数返回的就是一个迭代器，这意味着它生成的元素是按需计算的，而不是一次性生成所有元素。下面是更详细的解释：

# ### 迭代器的概念

# 1. **迭代器是什么？**
#    - 迭代器是实现了 `__iter__()` 和 `__next__()` 方法的对象。
#    - 可以使用 `for` 循环或 `next()` 函数逐个访问其元素。

# 2. **与列表的区别**
#    - 列表会一次性将所有元素加载到内存中，而迭代器按需生成元素，节省内存。
#    - 迭代器只能遍历一次，无法反复访问已遍历的元素。

# ### `zip()` 返回的迭代器

# - **按需生成**：`zip()` 返回一个迭代器，这个迭代器按需生成每一个包含多个输入可迭代对象对应元素的元组。
# - **懒加载**：只有在实际需要元素时（例如在 `for` 循环中），`zip()` 才会生成下一个元组，这样可以节省内存。

### 示例

#### 使用 `zip()` 返回的迭代器


# list1 = [1, 2, 3]
# list2 = ['a', 'b', 'c']

# zipped = zip(list1, list2)  # 返回一个迭代器
# print(zipped)  # 输出: <zip object at 0x...>

# for item in zipped:
#     print(item)  # 逐个生成并打印元组 (1, 'a'), (2, 'b'), (3, 'c')
# ```

# #### 将 `zip()` 的结果转换为列表

# ```python
# list1 = [1, 2, 3]
# list2 = ['a', 'b', 'c']

# zipped = zip(list1, list2)
# zipped_list = list(zipped)  # 转换为列表
# print(zipped_list)  # 输出: [(1, 'a'), (2, 'b'), (3, 'c')]
# ```

# 在 `zipped_list` 之后，如果你尝试再次迭代 `zipped`，它将不会产生任何输出，因为迭代器已经被消耗完毕。

# ### 总结

# - **迭代器**：`zip()` 返回一个迭代器，按需生成结果。
# - **节省内存**：迭代器不一次性生成所有结果，有助于处理大型数据集。
# - **一次性遍历**：迭代器的元素在遍历一次后被消耗，不可重新访问。




# line += '{:>10.1f}'.format(data)

# 格式化说明
# {:>10.1f}：这是一个格式化说明符，用于指定如何显示 data 的值。
# >：表示右对齐。
# 10：表示字段宽度为 10 个字符。即整个字段的宽度，包括数字和任何填充的空格，总共为 10 个字符。
# .1f：表示将浮点数格式化为保留 1 位小数的形式
